// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/operator-framework/api/pkg/operators/v1alpha1

package v1alpha1

#CatalogSourceCRDAPIVersion: "operators.coreos.com/v1alpha1"
#CatalogSourceKind:          "CatalogSource"

// SourceType indicates the type of backing store for a CatalogSource
#SourceType: string // #enumSourceType

#enumSourceType:
	#SourceTypeInternal |
	#SourceTypeConfigmap |
	#SourceTypeGrpc

// SourceTypeInternal (deprecated) specifies a CatalogSource of type SourceTypeConfigmap
#SourceTypeInternal: #SourceType & "internal"

// SourceTypeConfigmap specifies a CatalogSource that generates a configmap-server registry
#SourceTypeConfigmap: #SourceType & "configmap"

// SourceTypeGrpc specifies a CatalogSource that can use an operator registry image to generate a
// registry-server or connect to a pre-existing registry at an address.
#SourceTypeGrpc: #SourceType & "grpc"

// CatalogSourceSpecInvalidError denotes when fields on the spec of the CatalogSource are not valid.
#CatalogSourceSpecInvalidError: #ConditionReason & "SpecInvalidError"

// CatalogSourceConfigMapError denotes when there is an issue extracting manifests from the specified ConfigMap.
#CatalogSourceConfigMapError: #ConditionReason & "ConfigMapError"

// CatalogSourceRegistryServerError denotes when there is an issue querying the specified registry server.
#CatalogSourceRegistryServerError: #ConditionReason & "RegistryServerError"

#CatalogSourceSpec: {
	// SourceType is the type of source
	sourceType: #SourceType @go(SourceType)

	// ConfigMap is the name of the ConfigMap to be used to back a configmap-server registry.
	// Only used when SourceType = SourceTypeConfigmap or SourceTypeInternal.
	// +Optional
	configMap?: string @go(ConfigMap)

	// Address is a host that OLM can use to connect to a pre-existing registry.
	// Format: <registry-host or ip>:<port>
	// Only used when SourceType = SourceTypeGrpc.
	// Ignored when the Image field is set.
	// +Optional
	address?: string @go(Address)

	// Image is an operator-registry container image to instantiate a registry-server with.
	// Only used when SourceType = SourceTypeGrpc.
	// If present, the address field is ignored.
	// +Optional
	image?: string @go(Image)

	// UpdateStrategy defines how updated catalog source images can be discovered
	// Consists of an interval that defines polling duration and an embedded strategy type
	// +Optional
	updateStrategy?: null | #UpdateStrategy @go(UpdateStrategy,*UpdateStrategy)

	// Secrets represent set of secrets that can be used to access the contents of the catalog.
	// It is best to keep this list small, since each will need to be tried for every catalog entry.
	// +Optional
	secrets?: [...string] @go(Secrets,[]string)

	// Metadata
	displayName?: string @go(DisplayName)
	description?: string @go(Description)
	publisher?:   string @go(Publisher)
	icon?:        #Icon  @go(Icon)
}

// UpdateStrategy holds all the different types of catalog source update strategies
// Currently only registry polling strategy is implemented
#UpdateStrategy: {
	registryPoll?: null | #RegistryPoll @go(RegistryPoll,*RegistryPoll)
}

#RegistryPoll: {
	// Interval is used to determine the time interval between checks of the latest catalog source version.
	// The catalog operator polls to see if a new version of the catalog source is available.
	// If available, the latest image is pulled and gRPC traffic is directed to the latest catalog source.
	interval?: null | #Duration @go(Interval,*github.com/operator-framework/api/vendor/metav1.Duration)
}

#RegistryServiceStatus: {
	protocol?:         string @go(Protocol)
	serviceName?:      string @go(ServiceName)
	serviceNamespace?: string @go(ServiceNamespace)
	port?:             string @go(Port)
	createdAt?:        #Time  @go(CreatedAt,github.com/operator-framework/api/vendor/metav1.Time)
}

#GRPCConnectionState: {
	address?:          string @go(Address)
	lastObservedState: string @go(LastObservedState)
	lastConnect?:      #Time  @go(LastConnectTime,github.com/operator-framework/api/vendor/metav1.Time)
}

#CatalogSourceStatus: {
	// A human readable message indicating details about why the CatalogSource is in this condition.
	// +optional
	message?: string @go(Message)

	// Reason is the reason the CatalogSource was transitioned to its current state.
	// +optional
	reason?: #ConditionReason @go(Reason)

	// The last time the CatalogSource image registry has been polled to ensure the image is up-to-date
	latestImageRegistryPoll?: null | #Time                       @go(LatestImageRegistryPoll,*github.com/operator-framework/api/vendor/metav1.Time)
	configMapReference?:      null | #ConfigMapResourceReference @go(ConfigMapResource,*ConfigMapResourceReference)
	registryService?:         null | #RegistryServiceStatus      @go(RegistryServiceStatus,*RegistryServiceStatus)
	connectionState?:         null | #GRPCConnectionState        @go(GRPCConnectionState,*GRPCConnectionState)
}

#ConfigMapResourceReference: {
	name:             string @go(Name)
	namespace:        string @go(Namespace)
	uid?:             #UID   @go(UID,github.com/operator-framework/api/vendor/types.UID)
	resourceVersion?: string @go(ResourceVersion)
	lastUpdateTime?:  #Time  @go(LastUpdateTime,github.com/operator-framework/api/vendor/metav1.Time)
}

// CatalogSource is a repository of CSVs, CRDs, and operator packages.
#CatalogSource: {
	#TypeMeta
	metadata: #ObjectMeta        @go(ObjectMeta,github.com/operator-framework/api/vendor/metav1.ObjectMeta)
	spec:     #CatalogSourceSpec @go(Spec)

	// +optional
	status: #CatalogSourceStatus @go(Status)
}

// CatalogSourceList is a repository of CSVs, CRDs, and operator packages.
#CatalogSourceList: {
	#TypeMeta
	metadata: #ListMeta @go(ListMeta,github.com/operator-framework/api/vendor/metav1.ListMeta)
	items: [...#CatalogSource] @go(Items,[]CatalogSource)
}
