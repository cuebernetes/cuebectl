// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/operator-framework/api/pkg/operators/v1alpha1

package v1alpha1

#SubscriptionKind:          "Subscription"
#SubscriptionCRDAPIVersion: "operators.coreos.com/v1alpha1"

// SubscriptionState tracks when updates are available, installing, or service is up to date
#SubscriptionState: string

#SubscriptionStateNone:             ""
#SubscriptionStateFailed:           "UpgradeFailed"
#SubscriptionStateUpgradeAvailable: "UpgradeAvailable"
#SubscriptionStateUpgradePending:   "UpgradePending"
#SubscriptionStateAtLatest:         "AtLatestKnown"

#SubscriptionReasonInvalidCatalog:   #ConditionReason & "InvalidCatalog"
#SubscriptionReasonUpgradeSucceeded: #ConditionReason & "UpgradeSucceeded"

// SubscriptionSpec defines an Application that can be installed
#SubscriptionSpec: {
	source:               string              @go(CatalogSource)
	sourceNamespace:      string              @go(CatalogSourceNamespace)
	name:                 string              @go(Package)
	channel?:             string              @go(Channel)
	startingCSV?:         string              @go(StartingCSV)
	installPlanApproval?: #Approval           @go(InstallPlanApproval)
	config?:              #SubscriptionConfig @go(Config)
}

// SubscriptionConfig contains configuration specified for a subscription.
#SubscriptionConfig: {
	// Selector is the label selector for pods to be configured.
	// Existing ReplicaSets whose pods are
	// selected by this will be the ones affected by this deployment.
	// It must match the pod template's labels.
	selector?: null | #LabelSelector @go(Selector,*github.com/operator-framework/api/vendor/metav1.LabelSelector)

	// NodeSelector is a selector which must be true for the pod to fit on a node.
	// Selector which must match a node's labels for the pod to be scheduled on that node.
	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	// +optional
	nodeSelector?: {[string]: string} @go(NodeSelector,map[string]string)

	// Tolerations are the pod's tolerations.
	// +optional
	tolerations?: [...#Toleration] @go(Tolerations,[]github.com/operator-framework/api/vendor/corev1.Toleration)

	// Resources represents compute resources required by this container.
	// Immutable.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	// +optional
	resources?: #ResourceRequirements @go(Resources,github.com/operator-framework/api/vendor/corev1.ResourceRequirements)

	// EnvFrom is a list of sources to populate environment variables in the container.
	// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
	// will be reported as an event when the container is starting. When a key exists in multiple
	// sources, the value associated with the last source will take precedence.
	// Values defined by an Env with a duplicate key will take precedence.
	// Immutable.
	// +optional
	envFrom?: [...#EnvFromSource] @go(EnvFrom,[]github.com/operator-framework/api/vendor/corev1.EnvFromSource)

	// Env is a list of environment variables to set in the container.
	// Cannot be updated.
	// +patchMergeKey=name
	// +patchStrategy=merge
	// +optional
	env?: [...#EnvVar] @go(Env,[]github.com/operator-framework/api/vendor/corev1.EnvVar)

	// List of Volumes to set in the podSpec.
	// +optional
	volumes?: [...#Volume] @go(Volumes,[]github.com/operator-framework/api/vendor/corev1.Volume)

	// List of VolumeMounts to set in the container.
	// +optional
	volumeMounts?: [...#VolumeMount] @go(VolumeMounts,[]github.com/operator-framework/api/vendor/corev1.VolumeMount)
}

// SubscriptionConditionType indicates an explicit state condition about a Subscription in "abnormal-true"
// polarity form (see https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties).
#SubscriptionConditionType: string // #enumSubscriptionConditionType

#enumSubscriptionConditionType:
	#SubscriptionCatalogSourcesUnhealthy |
	#SubscriptionInstallPlanMissing |
	#SubscriptionInstallPlanPending |
	#SubscriptionInstallPlanFailed

// SubscriptionCatalogSourcesUnhealthy indicates that some or all of the CatalogSources to be used in resolution are unhealthy.
#SubscriptionCatalogSourcesUnhealthy: #SubscriptionConditionType & "CatalogSourcesUnhealthy"

// SubscriptionInstallPlanMissing indicates that a Subscription's InstallPlan is missing.
#SubscriptionInstallPlanMissing: #SubscriptionConditionType & "InstallPlanMissing"

// SubscriptionInstallPlanPending indicates that a Subscription's InstallPlan is pending installation.
#SubscriptionInstallPlanPending: #SubscriptionConditionType & "InstallPlanPending"

// SubscriptionInstallPlanFailed indicates that the installation of a Subscription's InstallPlan has failed.
#SubscriptionInstallPlanFailed: #SubscriptionConditionType & "InstallPlanFailed"

// NoCatalogSourcesFound is a reason string for Subscriptions with unhealthy CatalogSources due to none being available.
#NoCatalogSourcesFound: "NoCatalogSourcesFound"

// AllCatalogSourcesHealthy is a reason string for Subscriptions that transitioned due to all CatalogSources being healthy.
#AllCatalogSourcesHealthy: "AllCatalogSourcesHealthy"

// CatalogSourcesAdded is a reason string for Subscriptions that transitioned due to CatalogSources being added.
#CatalogSourcesAdded: "CatalogSourcesAdded"

// CatalogSourcesUpdated is a reason string for Subscriptions that transitioned due to CatalogSource being updated.
#CatalogSourcesUpdated: "CatalogSourcesUpdated"

// CatalogSourcesDeleted is a reason string for Subscriptions that transitioned due to CatalogSources being removed.
#CatalogSourcesDeleted: "CatalogSourcesDeleted"

// UnhealthyCatalogSourceFound is a reason string for Subscriptions that transitioned because an unhealthy CatalogSource was found.
#UnhealthyCatalogSourceFound: "UnhealthyCatalogSourceFound"

// ReferencedInstallPlanNotFound is a reason string for Subscriptions that transitioned due to a referenced InstallPlan not being found.
#ReferencedInstallPlanNotFound: "ReferencedInstallPlanNotFound"

// InstallPlanNotYetReconciled is a reason string for Subscriptions that transitioned due to a referenced InstallPlan not being reconciled yet.
#InstallPlanNotYetReconciled: "InstallPlanNotYetReconciled"

// InstallPlanFailed is a reason string for Subscriptions that transitioned due to a referenced InstallPlan failing without setting an explicit failure condition.
#InstallPlanFailed: "InstallPlanFailed"

// SubscriptionCondition represents the latest available observations of a Subscription's state.
#SubscriptionCondition: {
	// Type is the type of Subscription condition.
	type: #SubscriptionConditionType @go(Type)

	// Status is the status of the condition, one of True, False, Unknown.
	status: #ConditionStatus @go(Status,github.com/operator-framework/api/vendor/corev1.ConditionStatus)

	// Reason is a one-word CamelCase reason for the condition's last transition.
	// +optional
	reason?: string @go(Reason)

	// Message is a human-readable message indicating details about last transition.
	// +optional
	message?: string @go(Message)

	// LastHeartbeatTime is the last time we got an update on a given condition
	// +optional
	lastHeartbeatTime?: null | #Time @go(LastHeartbeatTime,*github.com/operator-framework/api/vendor/metav1.Time)

	// LastTransitionTime is the last time the condition transit from one status to another
	// +optional
	lastTransitionTime?: null | #Time @go(LastTransitionTime,*github.com/operator-framework/api/vendor/metav1.Time)
}

#SubscriptionStatus: {
	// CurrentCSV is the CSV the Subscription is progressing to.
	// +optional
	currentCSV?: string @go(CurrentCSV)

	// InstalledCSV is the CSV currently installed by the Subscription.
	// +optional
	installedCSV?: string @go(InstalledCSV)

	// Install is a reference to the latest InstallPlan generated for the Subscription.
	// DEPRECATED: InstallPlanRef
	// +optional
	installplan?: null | #InstallPlanReference @go(Install,*InstallPlanReference)

	// State represents the current state of the Subscription
	// +optional
	state?: #SubscriptionState @go(State)

	// Reason is the reason the Subscription was transitioned to its current state.
	// +optional
	reason?: #ConditionReason @go(Reason)

	// InstallPlanGeneration is the current generation of the installplan
	// +optional
	installPlanGeneration?: int @go(InstallPlanGeneration)

	// InstallPlanRef is a reference to the latest InstallPlan that contains the Subscription's current CSV.
	// +optional
	installPlanRef?: null | #ObjectReference @go(InstallPlanRef,*github.com/operator-framework/api/vendor/corev1.ObjectReference)

	// CatalogHealth contains the Subscription's view of its relevant CatalogSources' status.
	// It is used to determine SubscriptionStatusConditions related to CatalogSources.
	// +optional
	catalogHealth?: [...#SubscriptionCatalogHealth] @go(CatalogHealth,[]SubscriptionCatalogHealth)

	// Conditions is a list of the latest available observations about a Subscription's current state.
	// +optional
	conditions?: [...#SubscriptionCondition] @go(Conditions,[]SubscriptionCondition)

	// LastUpdated represents the last time that the Subscription status was updated.
	lastUpdated: #Time @go(LastUpdated,github.com/operator-framework/api/vendor/metav1.Time)
}

#InstallPlanReference: {
	apiVersion: string @go(APIVersion)
	kind:       string @go(Kind)
	name:       string @go(Name)
	uuid:       #UID   @go(UID,github.com/operator-framework/api/vendor/types.UID)
}

// SubscriptionCatalogHealth describes the health of a CatalogSource the Subscription knows about.
#SubscriptionCatalogHealth: {
	// CatalogSourceRef is a reference to a CatalogSource.
	catalogSourceRef?: null | #ObjectReference @go(CatalogSourceRef,*github.com/operator-framework/api/vendor/corev1.ObjectReference)

	// LastUpdated represents the last time that the CatalogSourceHealth changed
	lastUpdated?: null | #Time @go(LastUpdated,*github.com/operator-framework/api/vendor/metav1.Time)

	// Healthy is true if the CatalogSource is healthy; false otherwise.
	healthy: bool @go(Healthy)
}

// Subscription keeps operators up to date by tracking changes to Catalogs.
#Subscription: {
	#TypeMeta
	metadata: #ObjectMeta              @go(ObjectMeta,github.com/operator-framework/api/vendor/metav1.ObjectMeta)
	spec?:    null | #SubscriptionSpec @go(Spec,*SubscriptionSpec)

	// +optional
	status: #SubscriptionStatus @go(Status)
}

// SubscriptionList is a list of Subscription resources.
#SubscriptionList: {
	#TypeMeta
	metadata: #ListMeta @go(ListMeta,github.com/operator-framework/api/vendor/metav1.ListMeta)
	items: [...#Subscription] @go(Items,[]Subscription)
}
